import ScrollMagic from 'scrollmagic';
export class LottieScrollComponent {
    constructor() {
        /**
         * data JSON location
         */
        this.src = '';
        /**
         * the speed of the animation
         */
        this.speed = 1;
        /**
         * If `true` it's only playing the animation, while if it's `false` the animation follows the scroll progression.
         */
        this.playthrough = false;
        this.scrollController = new ScrollMagic.Controller();
    }
    async onAnimationLoaded(event) {
        if (event.detail.animation) {
            await this.addAnimation();
        }
    }
    async addAnimation() {
        const scrollScene = new ScrollMagic.Scene({
            triggerElement: this.animationContainerElement,
            offset: 0,
            duration: this.animationContainerElement.clientHeight / this.speed,
        });
        if (this.playthrough) {
            this.lottieAnimationComponent.setSpeed(this.speed);
            scrollScene.triggerHook(0.66);
            scrollScene.on('enter', (e) => {
                if (e.scrollDirection === 'FORWARD') {
                    this.lottieAnimationComponent.play();
                    this.onAnimationStart.emit();
                }
            });
            const scrollSceneOut = new ScrollMagic.Scene({
                triggerElement: this.animationContainerElement,
                triggerHook: 1,
                offset: 0,
                duration: window.innerHeight,
            });
            scrollSceneOut.on('leave', (e) => {
                if (e.scrollDirection === 'REVERSE') {
                    this.lottieAnimationComponent.progress(0);
                    this.lottieAnimationComponent.stop();
                    this.onAnimationStop.emit();
                }
            });
            scrollSceneOut.addTo(this.scrollController);
        }
        else {
            const totalFrames = await this.lottieAnimationComponent.getTotalFrames();
            scrollScene.duration((window.innerHeight / 3) / this.speed);
            scrollScene.on('enter', () => {
                this.onAnimationStart.emit();
            });
            scrollScene.on('leave', () => {
                this.onAnimationStop.emit();
            });
            scrollScene.on('progress', ({ progress }) => {
                this.lottieAnimationComponent.goToAndStop(Math.round(progress * totalFrames), true);
            });
        }
        scrollScene.addTo(this.scrollController);
    }
    render() {
        return (h("div", { class: "lottie-scroll" },
            h("div", { class: "lottie-scroll__container", ref: (el) => this.animationContainerElement = el },
                h("lottie-animation", { src: this.src, autoplay: false, ref: (el) => this.lottieAnimationComponent = el, class: "lottie-scroll__animation" }))));
    }
    static get is() { return "lottie-scroll"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "playthrough": {
            "type": Boolean,
            "attr": "playthrough"
        },
        "speed": {
            "type": Number,
            "attr": "speed"
        },
        "src": {
            "type": String,
            "attr": "src"
        },
        "wrapperElement": {
            "elementRef": true
        }
    }; }
    static get events() { return [{
            "name": "onAnimationStart",
            "method": "onAnimationStart",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "onAnimationStop",
            "method": "onAnimationStop",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "onAnimationLoaded",
            "method": "onAnimationLoaded"
        }]; }
    static get style() { return "/**style-placeholder:lottie-scroll:**/"; }
}
